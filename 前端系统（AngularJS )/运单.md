工单 完成之后  快递员将取件 交到配送点 生成运单


dataGrid 行编辑 :实现运单的快速录入


业务了解-->业务预定-->业务下单-->接收业务订单数据-->工单(快递员的取件任务 将快递取回业务网店

 形成运单  前面的一切操作都是为了运单铺垫 物流系统的入口)

当运单开始 就开始运输  包含 货物信息 发件人 收件人 包装 计费 运输信息 

运单 和 订单的关系
运单编号必须唯一



第一个业务功能:
快读录入
优点:满足配载才有的功能 货量大单子多的时候 的 工作途径

	如果不这样 只录入完整的信息 工作效率会很慢 

缺点:残缺 不完整

如何实现快速录入?


如何补全信息?

查询运单?

条件查询:搜索引擎  解决大量数据查询慢的问题 

就需要使用算法 来选定数据结构存储数据

datagrid  列属性editor  有三个方法: beginEditor 开始编辑

endEditor提交编辑   cancleEditor关闭编辑    index  

getselected  row;

getRowindex   index 




# 序列化表单值有什么做用？ #
	序列化表单的作用 是为了方便ajax传递表单值给服务端 不然就只能自己手机表单的值

	将表单元素序列化成一个字符串  这样在传递data时就只需要将序列化后的

# BOM和DOM #

	bom是浏览器对象模型   主要用户获取  浏览器的属性和行为 

	dom

算法:数据结构

使用原本的递归循环

会发现传入的值一旦变大之后 其中递归的规模就越来越大

每一此 获取n的值 都需要再去递归获取n-1 n-2的值 

而每一个n-1 又可以看作一个n  又要去获取n-1 n-2的值 

所以可能参数只是增大了一些 但其中的问题规模  确增大了很多倍 

且呈指数的形式 进行增长


 

如何优化斐波拉了数列?

	既然产生问题的原因就是 每次获取n  都需要获取n-1 n-2 
不如就将每一级的值 存储起来  比如 需要获取时  就区存储的容器中获取

所以最后当我们再去获取  就可以直接从容器中 获取n-1 n-2的值 不用递归再去层层获取

map<integer long> map = new hashMap<integer,long>()

当每次需要获取n 时 先去容器中找
		if(map.get(num)!=null){
		return map.get(num);
	}else{
		
		}
return map.get(num-1)+map.get(num-2);


关于位运算符  左移<< 和 右移>>?

		左移运算符就是将一盒数的各二进制位 向左移若干位

静态数组 和 动态数组的区别?

	一般普通的数组只要出了方法域  就会失去意义  
	而动态的数组 除了方法域之后也会一致存在 

	

1.serialize()方法

　　格式：var data = $("form").serialize();

　　功能：将表单内容序列化成一个字符串。

　　这样在ajax提交表单数据时，就不用一一列举出每一个参数。只需将data参数设置为 $("form").serialize() 即可。

直接打印一个对象 其实打印的是它的 this.getClass.getName + "@"+hashcode

打印hashcode 

为什么要有hashcode?
	首先必须了解其作用 再从它提供的作用 去分析为什么需要它
	再hashtable hashmap 中底层 都用其来比对或者确定对象的存储地址的

notify和notifyaLL
	从单词面上理解是通知的意思;
	all 是所有
	所以notify 是通知单个  notifyall 是通知所有
	notify 是通知单个线程 等待其对象被解锁区竞争
	notyfyall是通知所有  等待其对象被解锁区竞争
	相同点:都会推出wait状态
	被通知的对象等待的是 锁
	未被通知的对象等待的是 通知


0   1 
1   2
1   3
2   4
3   5

		


客户电话-->代替客户下单-->

