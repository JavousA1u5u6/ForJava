两系统之间 

CRM系统  里 肯定不止一张表

如何实现一个拦截器?
 自定义一个拦截器必须实现拦截器的接口 拦截器的使用:
1.先定义;
2.在引用使用;

  常见拦截器有哪些?CookieInterceptor,fileUpload,scopedModelDriven,actionMappingParams,modelDriven

过滤器和拦截器之间的区别?

1、拦截器是基于java的反射机制的，而过滤器是基于函数回调。
2、拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
4、拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
5、在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次
6、执行顺序 ：过滤前 - 拦截前 - Action处理 - 拦截后 - 过滤后。

产生冲突,

hibernate的配置 文件 因为经常再用 所以就冲突了 


为什么需要事务?

	 某个逻辑单元内的一组操作 可以根据事务的特性 进行描述  对并发控制的基本单位 对数据进行操作  要么一组操作全部成功  要么一组操作全部失败  事务的提出主要是为了解决并发情况下保持数据一致性的问题.
这时数据库的一个特性
●   Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
●   Consistency（一致性）：只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。
●   Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。
●   Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。

	

这些东西我了解过 但不是我自己做的



事务:事务的四大特性

保证事务的完整性   

增删改 

多表查询的控制事务



模型驱动拦截器




这个在系统里面经常会用到   


我作为一个调用者

什么是webService?webservice怎么使用?

	是一种远程调用的技术  通过这种技术可以访问到别的系统的资源

所谓远程调用，就是一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法，譬如，银联提供给商场的pos刷卡系统，商场的POS机转账调用的转账方法的代码其实是跑在银行服务器上。再比如，amazon，天气预报系统，淘宝网，校内网，百度等把自己的系统服务以webservice服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能，这样扩展了自己系统的市场占有率，往大的概念上吹，就是所谓的SOA应用  面向服务的结构。

	钱就被扣  这里面就用到了 webservice远程调用;     我们在pos通过一条特定的url   去访问指定服务器接口

就可以获的指定的资源  或者 执行指定的操作

	而在刚刚我说的这个小例子中   我们的pos机  在你刷卡时  就会远程调用银行服务接口 执行里面扣钱的方法
所以我们会发现 我们在pos机上一刷卡  我们存在银行的钱就随之耳扣  这其实就是底层调用的webservice;

WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序


接口调用者(客户端)   接口提供者(服务端) 

客户端 通过服务器定义的接口方法  组成一条url 通过指定的http方式   去访问

我们一般使用webService其实是使用它提供的框架  CXf  而CXF又有两种服务提供方式

ws(基于sopa协议)xml    rs(基于restful)xml/json


算法  不太懂  就别提 

项目  


如果没离职 

没离职   以前公司挺好的   但可能我还是想要想更好的发展  公司的项目   我并不在这个性趣上


你们的crm系统  里面有多少张表?

	crm中存放了 很多张表 主要跟我负责的模块最相关  

为什么需要事务管理?


	事务管理,最主要跟数据库的特性有关,对于我们要对数据库数据库进行

一定要满足数据库       


		
说说你了解的算法?

	我就研究的比较深的两个涉及算法的小demo

	算法真的是一门很有魅力的学科 

	作为一名程序员 想要往更高级的去发展  研究算法就是一条很好的路

	自从上一次辞职之后  休息了一段时间之后  在这段休息的时间中

	研究 了以下之前 比较模糊的点  和 一些底层技术  

互联网的各层协议:5大层;实体层-->链接层-->网络层-->应用层
	

一些基础的数据结构 如何更好的优化?     

一个是如何获取 一个栈的最小值


	1.首先  

一个是对斐波那契数列的优化

此次经过老师面试的一些感想:

	  1.说话要引导面试官到  自己熟悉的点上



1.那我招聘需要两年啊?

	对不起,可能我的工作经验不达标 ,但是我在大学中几年中积累了很多个开发经验


2.你们的电商上线了码 ,网址多少?

1.未上线   我在做到后期的时候离职了
2.上线了  找一个网址


3.电商项目 能支持最大的并发量多少?

我们这个电商项目是一个支持十万并发量的项目




4.有没有测试过?



5.怎么测试?

	一般

6.项目里面用的架构?

	前端 :bootstrap-angluars  
	
	怎么实现的bootstrap 响应式?

	不同的分娩率可以实现不同的样式   因为栅格系统 

 后端:   

7.jdbc简单的步骤
	首先需要加载驱动
	获取一个数据库连接对象
		
 
8.hibenate的快照机制?

	快照机制 其实就是hibernate 的一级缓存   使用这个机制

可以在事务范围内  对同一此事务中于数据库交互的数据进行 这样

就有利于在一次事务中 多次查询的烦恼 而且因为这个快照区  我们

在存储一个对象后  对这个对象进行修改 就不用再去写一个   修改的
方法 因为这个对象就在我们的快照去中  当我们对这个持久化的对象修改后

底层就会自动就 会发送一条修改语句  区更改数据  

1.先介绍下自己的之前的项目的经验  和 大学经历

	

2.你们做了一年多  一年多你参与了什么事情

	你在这个项目中都做了些什么  可以针对模块区说

3.跟踪货物

	在这里我们使用了baidu地图的api 车里规划线路

途径中转点显示   规划出一个大概的路径  

每到达一个中转点 就会生成一个

4.用户



5.搜索引擎能帮助我们干啥?



6.elsstic搜索引擎  这个玩意怎么用的?

	基于lucence:如果谈到搜索引擎,就肯定要说到lucence

因为  


比较两个对象?

	有三种方法实现

第一种直接用字符串类的compareTo方法：
1
2
3
  String t1="20131011";
  String t2="20131030";
  int result = t1.compareTo(t2);
第二种是把这个日期字符串转换成long：

1
2
3
4
  SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
  Date d1 = sdf.parse(t1);
  Date d2 = sdf.parse(t2);
  long result = d1.getTime()-d2.getTime();
第三种是把日期字符串转换成整形int：

1
2
3
  int int1 = Integer.parseInt(t1);
  int int2 = Integer.parseInt(t2);
  int result = int1-int2;
注：result大于0，则t1>t2；

       result等于0，则t1=t2；

       result小于0，则t1<t2；

两个对象必须要实现com

1.首先需要准备索引库的数据



oracle达集群了码?

怎么测试数据



介绍下:jsp

什么时候创建的?

	 jsp作为后台反应给前台数据存放的一个模板 但它本质还是一个servlet

什么时候访问  什么时候出现  出现的原因? 


你们公司在哪哪呢?


住哪儿呢?


怎么去?


你还有什么想了解的码?


在杭州以前基本上工资怎么样?
	

但你希望拿多少?


你从外面为啥回来?



运气页很关键,注意说话的方式,善于去记录,去总结;


谈工资最好不要让步?

	要多少就要多少


一个问题回答不下去了?

	就可以自己不会 开始下一个提


如果时间不足就给他说  我时间紧 笔试来不及做了 

你随便问我把   我都会~~!
	
记几个拦截器的名字


做一个小型的app 做一个微信公众号 

一个小公司  5万块

三个人起码要做一个月     


明天学mybatis, springMVC?


如何解决包冲突?

	首先包冲突 一定因为导入种技术的坐标时  与 之前 导入的坐标  他们的
groupid 和  artifctedid 冲突 




如何使用报表技术

G:\bos项目\bosv2.0_chapter10_运输配送流程、报表技术、linux部署\资料\资料\资料\新BOS项目资料_chapter10_02  IText报表\iText2.1.7

你们使用什么项目构建技术?

	maven

谈谈你对maven的理解?

	maven是apache 组织下开源的专门用来管理项目 

 每一个maven工程  都有一个pom文件   这个pom文件就是项目对象模型  里面定义了工程依赖的jar包

jar的坐标  

maven的核心?

	使用依赖管理系统通过坐标对项目所依赖的坐标进行统一管理

maven的生命周期?

maven有三大生命周期 : 每个生命周期 又分为许多阶段  后面的阶段依赖与之前的阶段   

但每个生命周期之间又是相互独立的


聚合与继承的区别?

	多个模块聚合在一起 叫聚合   而继承是指一个模块要继承另一个模块的功能

classpath和classpath*的区别:
	支持通配符
	classpath:只会到你指定的class路径种查找文件
	classpath*:不仅包含class路径，还包括jar文件中(class路径)进行查找.

依赖范围?

	在maven种 我们引入了种种依赖jar 

这其中有一些jar包  并不是在项目的整个生命周期 都需要的

比如junit  比如servlet-api  因为运行时 服务器会自动创建servlet 所以两者之间会冲动

还有jdbc驱动:  只在编译 和 测试时期会用到

所以我们必须设置对j一些ar包的依赖范围u
<scope>runtime/provider/compile(默认)</scope>


什么是依赖传递?
 比如说项目种 使用elasticSearch 它底层使用了 jackson

	另一个技术 引入jar包时   它底层也依赖了jackson

这会项目中就存在两个jackson的包了 

那主项目到底会采用哪个版本呢?

这时就会根据maven定义的依赖
原则来选择依赖的版本   路径有限原则 

如果路径相等  就会看谁被声明在前


如何排除依赖?

	排除依赖的原则:有限排除低版本的jar

	<exclusion></exclusion>

使用maven构建项目  可以 可以依托哪两种模式
1.根据模块拆分
2.根据层级拆分



oracle的分布式?

	节点



JVM的结构

	在window里划分了一块空间 专门给jvm  虚拟机使用 

jdk 1.7

堆 : 存放所有的对象  new xxx

栈 :  只存基本数据类型      存放变量名    ------->公有的

方法区 :  存放class  静态变量  



每一个线程都有自己私有的栈  

为什么私有?
	在方法里面的代码是安全的  因为线程私有 
	一个成员变量是共有的  就不安全了(如果要使用 就加锁)
	而局部变量 就安全的多 

springMVC就是单利的  

perGen?  持久带 存放我们的class 对象  就是方法区

一加载  对象太多了   就会爆  outofmermory  

		   					heap?堆

频繁调方法  不断的压栈  栈针   就会包栈溢出

jdk 1.8   移除了永久带   源空间


mybatis和hibernate 本质的区别?

mybatis:学习成本低,入门门槛低,需要程序员自己写sql 修改i和优化 比较i灵活  不完全的orm框架
也存在mapping(两大功能:输出,输入)

	适用于:需求变法过快   互联网  电商

	不适用: 不太会使用sql语句的人

hibernate :orm框架  不需要程序要来编写sql  自动根据对象映射生成sql;

实现了jpa接口

sun公司定义的持久层的接口   

	适用于:需求比较固定的一些oa系统 .erp系. 
 

企业在技术选型时:  需要考虑各个技术框架的特点  去 进行选型


什么问题呢?

	当现在三个方法一起执行时  就会出现一个并发访问的问题 

三个线程 通过sqlSession 去与数据库交互    

存在大量重复的代码 

还有硬编码的问题



java中 有几种锁机制?

	synchronized  使用JDK 5中提供的java.util.concurrent.lock包中的Lock对象。

关于锁的一些理解?'
	为什么需要锁
	java语言是面向对象的一种语言    俗话说的好 万物皆对象  
		有时候 往大了说 我觉得java就是 面向世界的   
	它的很多机制  都跟我们的现实生活很相像   比如 锁机制 
	 给我一把锁  我给你一个规矩  
	在我们生湖  中 需要规矩  而在 编程中 也是需要规矩的
	无规矩不成方圆

	什么时候需要锁呢?
	当两个线程同时访问  一个资源但是这个资源是不能共享的
	怎么办 我们就需要加个锁

	  就打一个最简单例子来说  网上买票
	
	我们必须





什么是jdk?

	java开发工具包

什么是jre?

	是java程序运行的必备环境

什么是jvm?

	是java虚拟机  就是在虚构出来的计算机  在实际的计算机上  模拟各种计算机

如何自定义一个线程
继承thread类

实现runnable

线程 和 进程的区别?

	 进程一般来说 是有单独的运行环境的 , 它可能是一个应用,可能是一个程序,
而线程呢, 线程是一个进程的子集,一个可能会有许多哥线程 去执行进程分配的任务,
而每一个线程呢  都共有一片内存空间,  但是每一个 线程都拥有单独的占内存用来存储本地数据


线程的5中状态?
	创建,就绪,运行,阻塞,终止

数据库指定一条记录的id时,使用uuid作为主键id有什么好处?

	1.优点:使用 uuid生成的id  再数据库的数据迁移时 不用担心会发生重复
	2.缺点: 但uuid作为索引   性能 没有数字索引高  (36位)

数据库的索引底层用的什么数据结构呢?

	主要基于hash表和b+树

数据库的索引为什么要使用树结构来存储呢?

	树的查询效率高 ,而且可以保持有序

那为什么不使用 二叉树来实现呢?

	二叉树查询的时间复杂度为0(logN),
解:其实从算法逻辑上来将,二叉查找树的查找速度和比较次数都是最小的.但是我们不得不考虑一个很现实的问题 :磁盘IO

因为数据索引是存储再磁盘上的  当数据量很大的时候 索引的大小可能会有几个g甚至更多

当我们利用索引查询的时候,能把整个索引都加载到内存码,显然是不可能的,只能琢一加载每一个磁盘页,这里的磁盘页就对应
索引树的节点

索引树的高度决定着磁盘io的次数  

所以为了减少磁盘io的次数  我们需要将树的高度变矮  身子变宽 


b-树的应用: 文件系统,以及部分数据库(mogondb)
b+树的应用:  数据库的索引


for 和 foreach 的区别?

		for:适用于复杂的循环, 可以通过index获得元素

		foreach:适用于简单的集合遍历,但在遍历过程中 会锁定集合对象的值 不能做修改


数据库的左外连接在什么时候会用到呢?

	在这样一种场景我们会用到左外连接:

	比如说 我们现在要统计 所有 用户的 用水情况

	如果使用普通的查询语句 只能找到用水的记录 但是使用 就能连没有用水记录的用户数据页查出来


静态变量和非静态变量的区别?

	首先静态变量在类一加载时  就会被分配存储空间

	而非静态 必须等到对象被创建了之后  
 
手写oracle 倒叙查询分页的slq语句?

注意:rownum 是查询语句 扫描到每条记录 时 才产生的,所以要想使用
rownum 来做查询    然后从中获取部分记录数

select * from
(select rownum r,t.* from
(select * from T_ACCOUNT order by usenum desc) t
where rownum<=20 )
where r>10


基于mysql分页查询s
	
SELECT * FROM tb_goods_info WHERE auto_id <2500 ORDER BY auto_id desc LIMIT 40,20;


classloader时如何加载类?


	java有一套独特的类加载机制, 不同的类加载器加载不同的类资源
	bootstrap加载 jdk源生类库
	extendClassLoader 加载 扩展的类库
	applicationClassloader 加载 用户自定义的类库


arraylist如何实现有序排放?

	底层重写add方法      使用compareTo 方法比较 输入的数 和 集合当前索引的 值  因为会返回3个结果

1 输入数大于当前索引值

2 输入数小于当前索引值

3. 输入数等于当前索引值

如果当前输入值  小于或者等于当前值  即返回不等于-1   就让当前的值等于此输入值是


treeMap 与 hashmap有什么区别?

hashmap:哈希表 ,效率比树结构要快一点,但是是无需的  

treemap:红黑树,有序的 ,如果需要有序的key  就可以使用treemap	


GC(Garbage Collection): 垃圾手机  清理加整理 

垃圾标记算法   垃圾不是都在一块  内存碎片比较 

垃圾整理   清理是就整理   重复的部分 就往前排  就空出来一大部分内存 

jvm堆

新生带:存储新生的对象
又分为eden和幼儿园s0,s1

老年带:新域中 经过一定次数额gc循环之后  还为被回收 就会被移入老年带 

永久域(jdk1.8北取消 新加一个mataspace(源空间)):存储类和方法对象 ,独立的空间  m默认4M
一样会触发Full GC.而且如果GC之后还是满的，就会抛出PermGen Space异常   

垃圾回收主要回收的是什么?
1.回收的区域: 堆  一级方法区的内存
2.回收的区域对象: 没有引用的对象


如何判断堆中的对象为垃圾呢?

	主要通过两种方法来判断    1. 引用计数器算法:如果有引用  就+1   如果没有引用为null 就为0   如果引用没了就减一

							2.可达性算法


新生带   和 老年带 满了之后 就会触发相应的垃圾回收器

young gc: 一般是在eden满了之后会触发 复制操作,比如遍历s0和eden中正在使用的对象 复制到另一个s1中 然后还可以进行相应的内存整理
将之前的对象 清空 
如果经历几次Young GC时新生代还是满的，还不能够接收Eden中过来的幸存对象，就会抛出java.lang.OutOfMemorryError：java heap space;

full gc: 一般实在老年代的数据满了之后 会触发   标记整理算法  第一阶段  对每个具有引用的对象节点进行标记  
Full GC后如果Old Generation还是满的，就抛出内存溢出异常：
java.lang.OutOfMemorryError：java heap space;

第二阶段  清除无引用对象  并且整理





关于序列化? 序列化的版本号有什么作用?




适配器模式?

	什么是适配器模式  

举个例子:在日常生活中  我们经常可以听到一个词  表压器

比如一般的用户 用电电压 220V  380v

就会看 你这个用户是
 
写个小demo了解以下

首先明确一个东西?
	为什么使用适配器模式  因为每个handler 必须实现controller这个接口 但是

controller是具有多种类型的  我们需要对每个handler进行判断 是否是某个XX

的子类

	这样如果后期  controller多了一重实现类 就要在代码中 加入一行判断

这种形式是的程序难以维护 也违反了设计原则中的开闭原则 对扩展开放 对修改关闭

因此spring定义了一种适配接口  使得每一种controller有一种对应的适配器实现类

让适配器代替controller执行相应的方法。这样在扩展Controller 时，只需要增加一个适配器类就完成了SpringMVC的扩展了，真的是很精巧的做法！ 

，它是一种补偿模式，专用来在系统后期扩展、修改时所用。


什么是枚举?

	就是实例已经固定的类

怎样设置单列模式?



枚举

暴力反射可以打破单列模式
怎么解决?
使用枚举
反序列化也会破坏
可以使用 readresolve

懒汉式:有安全性问题  就是可能发生多个线程同时访问


volatile :多列的 可变的

解决了指定排序  就按照默认的步骤来
1.分配空间2.创建对象ob  3赋值
优化机制:1.分配空间  2先赋值 指向空间


使用静态内部类   : 调用的时候会执行

枚举什么都可以解决


volatile :多列的 可变的
这个jdk为我们提供的关键字有什么用

		一般volatile多用于修饰 成员变量 当用此关键字修饰后   这个变量就具有了两个特性

可变性 和  可见性  

这两个特性有什么作用呢,   因为可变性  每一个线程运行中 对数据的修改 都会被强制 更新到元数据

而 因为可见性  所以每一个线程获取数据 都强制性要获取最新的数据



srpingmvc和struts2 框架的区别?
前端控制器 :  servlet    filter

接收参数:                         
	
s1:在controller定义形参来接收请求的参数 ,是通过参数绑定,springmvc可以使用单利模式

来管理controller.   基于方法开发  注解开发中 使用requestMapping 将url和方法进行映射

如果根据url找到了controller 类的方法生成了一个handler处理器对象(只包括一个method)

跟符合service 的开发习惯    



s2: action中定义成员变量 接收请求参数  只能使用多列模式来管理action 
  如果多线程访问一个实例    相当于共享了内存存储空间  所以在获取值的时候就有冲突
为了解决  你每个线程过来 我都会新建一个action   基于类开发  类中有若干方法

其实速度是相当的是 


所以说说你知道的创建对象的方式?

1.直接new 

2.clone

3.反射

4.反序列化


如果要进行单列模式?

	不仅仅需要对构造方法私有

还需要   禁止暴力发射
方式:在构造方法种添加如下代码,则对象无法创建
    SecurityManager sm = new SecurityManager();
    if (sm != null) {
        sm.checkPermission(new ReflectPermission("suppressAccessChecks"));
    }
禁止反序列化

   /**
     * 反序列化通过该方法来获取反序列化后的对象
     * 
     * @return
     * @throws ObjectStreamException
     */
    private Object readResolve() throws ObjectStreamException {
        return instance;
    }

-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2017.3\bin\JetbrainsCrack-2.6.2.jar











	














	


	        

	

